<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Screens</title>
  <link rel="stylesheet" href="triptych_v2.css" />
  <script type="text/javascript">
    /////////////////////////
    // CONSTANTS & GLOBALS //
    /////////////////////////
    const TRIPTYCH_VERSION = "23.9.28.1";

    // Custom element names must adhere to naming rules
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Components/Using_custom_elements#registering_a_custom_element
    const WIDGET_TYPE_TO_ELEMENT_NAME = {
      screen_normal: "screen-normal",
      screen_split: "screen-split",
      page_load_no_data: "page-load-no-data",
      no_data: "no-data",
      train_crowding: "train-crowding",
      evergreen_content: "evergreen-content",
      page_load_no_data: "page-load-no-data",
      no_data: "no-data"
    };

    const LOADING_LAYOUT = {
      full_screen: {
        type: "page_load_no_data",
      },
      type: "screen_normal",
    };

    const FAILURE_LAYOUT = {
      full_screen: {
        type: "no_data",
      },
      type: "screen_normal",
    };

    ////////////////////
    // COMPONENT DEFS //
    ////////////////////
    class App extends HTMLElement {
      set props({ type, ...subProps }) {
        if (type == null) throw new Error("type prop not passed to App");

        this._props = { type, subProps };
      }

      connectedCallback() {
        if (this._props) {
          const { type, subProps } = this._props;
          const template = document.getElementById("app-content-template").content.cloneNode(true);

          template.getElementById("triptych-shifter").className += ` triptych-shifter--${window.IDENTIFIERS.triptychPane}`;

          const content = document.createElement(WIDGET_TYPE_TO_ELEMENT_NAME[type]);
          content.props = { ...subProps };
          template.getElementById("screen-container").appendChild(content);

          this.attachShadow({ mode: "open" }).appendChild(template);
        } else {
          throw new Error("No props set on App before connecting to DOM");
        }
      }
    }

    class ScreenNormal extends HTMLElement {
      set props({ full_screen: fullScreen }) {
        if (fullScreen == null) throw new Error("full_screen prop not passed to ScreenNormal");

        this._props = { fullScreen };
      }

      connectedCallback() {
        if (this._props) {
          const { fullScreen: { type, ...subProps } } = this._props;

          const template = document.getElementById("screen-normal-template").content.cloneNode(true);

          const content = document.createElement(WIDGET_TYPE_TO_ELEMENT_NAME[type]);
          content.props = { ...subProps };
          template.getElementById("full-screen").appendChild(content);

          this.attachShadow({ mode: "open" }).appendChild(template);
        } else {
          throw new Error("No props set on ScreenNormal before connecting to DOM");
        }
      }
    }

    class ScreenSplit extends HTMLElement {
      set props({ left_pane: left, middle_pane: middle, right_pane: right }) {
        if (left == null) throw new Error("left_pane prop not passed to ScreenSplit");
        if (middle == null) throw new Error("middle_pane prop not passed to ScreenSplit");
        if (right == null) throw new Error("right_pane prop not passed to ScreenSplit");

        this._props = { left, middle, right };
      }

      connectedCallback() {
        if (this._props) {
          const template = document.getElementById("screen-split-template").content.cloneNode(true);

          // Choose which pane div to populate
          const { type, ...subProps } = this._props[window.IDENTIFIERS.triptychPane];
          const paneId = `${window.IDENTIFIERS.triptychPane}-pane`;

          const content = document.createElement(WIDGET_TYPE_TO_ELEMENT_NAME[type]);
          content.props = { ...subProps };
          template.getElementById(paneId).appendChild(content);

          this.attachShadow({ mode: "open" }).appendChild(template);
        } else {
          throw new Error("No props set on ScreenSplit before connecting to DOM");
        }
      }
    }

    class EvergreenContent extends HTMLElement {
      set props({ src, showIdentifiers }) {
        if (src == null) throw new Error("src prop not passed to EvergreenContent");
        if (showIdentifiers == null) throw new Error("showIdentifiers prop not passed to EvergreenContent");
        this._props = { src, showIdentifiers };
      }

      connectedCallback() {
        if (this._props) {
          const { src, showIdentifiers } = this._props;
          const template = document.getElementById("evergreen-content-template").content.cloneNode(true);

          template.getElementById("image").src = src;

          if (showIdentifiers) {
            template.getElementById("identifiers").innerText = `${TRIPTYCH_VERSION} ${window.IDENTIFIERS.playerName}`;
          }

          this.attachShadow({ mode: "open" }).appendChild(template);
        } else {
          throw new Error("No props set on EvergreenContent before connecting to DOM");
        }
      }
    }

    class TrainCrowding extends HTMLElement {
      set props({ arrivalTime, crowding, destination, front_car_direction: frontCarDirection, now, platform_position: platformPosition, show_identifiers: showIdentifiers }) {
        if (arrivalTime == null) throw new Error("arrivalTime prop not passed to TrainCrowding");
        if (crowding == null) throw new Error("crowding prop not passed to TrainCrowding");
        if (destination == null) throw new Error("destination prop not passed to TrainCrowding");
        if (frontCarDirection == null) throw new Error("front_car_direction prop not passed to TrainCrowding");
        if (now == null) throw new Error("now prop not passed to TrainCrowding");
        if (platformPosition == null) throw new Error("platform_position prop not passed to TrainCrowding");
        if (showIdentifiers == null) throw new Error("show_identifiers prop not passed to TrainCrowding");


        this._props = { arrivalTime, crowding, destination, frontCarDirection, now, platformPosition, showIdentifiers };
      }

      connectedCallback() {
        if (this._props) {
          const { arrivalTime, crowding, destination, frontCarDirection, now, platformPosition, showIdentifiers } = this._props;
          const template = document.getElementById("train-crowding-template").content.cloneNode(true);

          // TODO

          this.attachShadow({ mode: "open" }).appendChild(template);
        } else {
          throw new Error("No props set on TrainCrowding before connecting to DOM");
        }
      }
    }

    class PageLoadNoData extends HTMLElement {
      connectedCallback() {
        const template = document.getElementById("page-load-no-data-template").content.cloneNode(true);

        this.attachShadow({ mode: "open" }).appendChild(template);
      }
    }

    class NoData extends HTMLElement {
      connectedCallback() {
        const template = document.getElementById("no-data-template").content.cloneNode(true);

        this.attachShadow({ mode: "open" }).appendChild(template);
      }
    }


    // Register them all so we can use them.
    customElements.define("app-content", App);
    customElements.define("screen-normal", ScreenNormal);
    customElements.define("screen-split", ScreenSplit);
    customElements.define("evergreen-content", EvergreenContent);
    customElements.define("train-crowding", TrainCrowding);
    customElements.define("page-load-no-data", PageLoadNoData);
    customElements.define("no-data", NoData);

    //////////
    // MAIN //
    //////////
    //////////////////////////////////////
    (() => {
      const BASE_MRAID = {
        // Stubbed methods/fields for foreground detection logic
        EVENTS: { ONSCREEN: "fakeOnscreenEvent" },
        requestInit() {
          return "fakeLayoutID";
        },
        addEventListener(eventID, callback, layoutID) {
          if (eventID == "fakeOnscreenEvent" && layoutID == "fakeLayoutID") {
            console.log(
              "FakeMRAID: Setting fake ONSCREEN event to fire in 3 seconds"
            );

            setTimeout(() => {
              console.log("FakeMRAID: Firing fake ONSCREEN event");
              callback();
            }, 2000);
          } else {
            throw new Error(
              "FakeMRAID: Stubbed addEventListener method expected eventID of 'fakeOnscreenEvent' and layoutID of 'fakeLayoutID'"
            );
          }
        },
      };

      const options = { playerName: "BKB-DS-003", station: "Back Bay", triptychPane: "right" }
      const { playerName, station, triptychPane } = options;

      const triptychPaneToArrayConfiguration = (pane) => {
        return `Triple_${pane[0].toUpperCase().concat(pane.slice(1))}`;
      };

      let tags = [{ name: "Station", value: [station] }];
      if (triptychPane) {
        tags.push({
          name: "Array_configuration",
          value: [triptychPaneToArrayConfiguration(triptychPane)],
        });
      }
      const tagsJSON = JSON.stringify({ tags });

      const deviceInfoJSON = JSON.stringify({ deviceName: playerName });

      const mraid = {
        ...BASE_MRAID,
        getTags() {
          return tagsJSON;
        },
        getDeviceInfo() {
          return deviceInfoJSON;
        },
      };

      // Be noisy about it so that we don't accidentally ship a package that calls this function.
      alert(
        `Setting fake MRAID object for testing purposes: ${JSON.stringify(options)}`
      );

      // Since `window.parent.parent.parent...` returns itself if the window does not have a parent, we can just set the mraid object
      // on the current window, and the code that reads `window.parent.parent.mraid` will still access it correctly.
      window.mraid = mraid;
    })();
    //////////////////////////////////////

    const _sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const _getMRAID = async () => {
      const mraid = parent?.parent?.mraid ?? false;
      if (mraid) {
        return mraid;
      } else {
        await _sleep(5);
        return _getMRAID();
      }
    };

    const _getTags = (mraid) => {
      try {
        return JSON.parse(mraid.getTags()).tags;
      } catch (err) {
        renderData(FAILURE_LAYOUT);
        throw err;
      }
    };

    const _getPlayerName = (mraid) => {
      try {
        const deviceInfoJSON = mraid.getDeviceInfo();
        console.log("deviceInfoJSON is", deviceInfoJSON);
        const deviceInfo = JSON.parse(deviceInfoJSON);
        console.log("deviceInfo is", deviceInfo);
        return deviceInfo.deviceName;
      } catch (err) {
        renderData(FAILURE_LAYOUT);
        throw err;
      }
    };

    const _arrayConfigurationToTriptychPane = (arrayConfiguration) => {
      switch (arrayConfiguration) {
        case "Triple_Left":
          return "left";
        case "Triple_Middle":
          return "middle";
        case "Triple_Right":
          return "right";
        default:
          renderData(FAILURE_LAYOUT);
          throw new Error(`Couldn't parse Array_configuration value: ${arrayConfiguration}`);
      }
    };

    const setOutfrontContext = async () => {
      const mraid = await _getMRAID();
      const playerName = _getPlayerName(mraid);
      const tags = _getTags(mraid);

      const arrayConfiguration = tags.find(({ name }) => name === "Array_configuration")?.value?.[0] ?? null;
      const triptychPane = _arrayConfigurationToTriptychPane(arrayConfiguration);

      window.IDENTIFIERS = { playerName, triptychPane };
      return "ok";
    }

    const renderData = (data) => {
      const app = document.createElement("app-content");
      app.props = { ...data };

      const root = document.getElementById("app");
      root.replaceChildren(app);
    };

    async function fetchData(playerName, triptychPane) {
      try {
        const result = await fetch(`https://screens.mbta.com/v2/api/screen/${playerName}/triptych?is_real_screen=true&last_refresh="2020-09-25T17:23:00Z"`);
        const json = await result.json();

        if (json.data == null || json.disabled) {
          // Show error template
          return FAILURE_LAYOUT;
        } else {
          return json.data;
        }
      } catch (err) {
        // Show error template
        renderData(FAILURE_LAYOUT);
        throw err;
      }
    };

    document.onreadystatechange = async function () {
      if (document.readyState === "interactive") {
        // Render without components at first so we don't depend on window.IDENTIFIERS
        // (Instead of just calling `renderData(LOADING_LAYOUT);`)
        const loadingPageTemplate = document.getElementById("zero-dependency-page-load-no-data-template").content.cloneNode(true);
        const appRoot = document.getElementById("app");
        appRoot.replaceChildren(loadingPageTemplate);

        await setOutfrontContext();

        const layoutData = await fetchData(window.IDENTIFIERS.playerName, window.IDENTIFIERS.triptychPane);
        renderData(layoutData);
      }
    };
  </script>
</head>

<body>
  <div id="app"></div>
</body>

<template id="zero-dependency-page-load-no-data-template">
  <div class="triptych-screen-viewport">
    <div class="triptych-shifter" id="triptych-shifter">
      <div class="screen-container" id="screen-container">
        <div className="full-screen" id="full-screen">
          <div class="no-data-left">
            <img src="images/loading-triptych.webp" />
          </div>
          <div class="no-data-middle">
            <img src="images/loading-triptych.webp" />
          </div>
          <div class="no-data-right">
            <img src="images/loading-triptych.webp" />
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<template id="page-load-no-data-template">
  <div class="no-data-left">
    <img src="images/loading-triptych.webp" />
  </div>
  <div class="no-data-middle">
    <img src="images/loading-triptych.webp" />
  </div>
  <div class="no-data-right">
    <img src="images/loading-triptych.webp" />
  </div>
</template>

<template id="no-data-template">
  <div class="no-data-left">
    <img src="images/no-data-triptych.webp" />
  </div>
  <div class="no-data-middle">
    <img src="images/no-data-triptych.webp" />
  </div>
  <div class="no-data-right">
    <img src="images/no-data-triptych.webp" />
  </div>
</template>

<template id="app-content-template">
  <div class="triptych-screen-viewport">
    <div class="triptych-shifter" id="triptych-shifter">
      <div class="screen-container" id="screen-container">
      </div>
    </div>
  </div>
</template>

<template id="screen-normal-template">
  <div className="full-screen" id="full-screen">
  </div>
</template>

<template id="screen-split-template">
  <div className="left-pane" id="left-pane"></div>
  <div className="middle-pane" id="middle-pane"></div>
  <div className="right-pane" id="right-pane"></div>
</template>

<template id="train-crowding-template">
  <slot name="content">NEED CROWDING CONTENT</slot>
</template>

<template id="evergreen-content-template">
  <div class="evergreen-content-image__container">
    <img class="evergreen-content-image__image" id="image">
  </div>
  <div class="evergreen-content__identifiers" id="identifiers"></div>
</template>

</html>
